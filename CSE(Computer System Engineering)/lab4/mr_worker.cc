#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

inline bool isValidCharacter(const char c) {
    return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z'); 
}

unsigned int myHash(const string &s) {
	unsigned long long hashVal = 0;
    for (const char &ch : s) {
        hashVal = hashVal * 33 + ch;
    }
    return hashVal % REDUCER_COUNT;
}

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	vector<KeyVal> res;

    int p = 0;
    int len = content.length();
    while (true) {
        while (p < len && !isValidCharacter(content[p]))  ++p;
        if (p < len) {
            int q = p + 1;
            KeyVal kv;

            while (q < len && isValidCharacter(content[q]))  ++q;

            kv.key = content.substr(p, q - p);
            kv.val = "1";
            res.push_back(kv);

            p = q + 1;
        }
        else {
            break;
        }
    }

    return res;
}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
	unsigned long long res = 0;

    for (auto &it: values) {
        res += stoull(it);
    }

    return to_string(res);
}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const string &filename);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const string &filename)
{
	// Lab2: Your code goes here.
	const static string filePrefix = basedir + "mr-" + to_string(index) + "-";
	string buf;

	ifstream in(filename);
	ostringstream os;
	os << in.rdbuf();
	buf = os.str();
	in.close();

	auto kvs = Map(filename, buf);

	vector<string> bufs(REDUCER_COUNT);
	for (auto &it : kvs) {
		auto index = myHash(it.key);
		bufs[index].append(it.key + ' ' + it.val + '\n');
	}

	for (unsigned int i = 0; i < REDUCER_COUNT; ++i) {
		ofstream out(filePrefix + to_string(i), ios::out | ios::app);
		mtx.lock();
		out << bufs[i];
		mtx.unlock();
		out.close();
	}
}

void Worker::doReduce(int index)
{
	// Lab2: Your code goes here.
	unsigned int i = 0;
	map<string, unsigned long long> kvs;
	while (true) {
		string filePath = basedir + "mr-" + to_string(i) + "-" + to_string(index);
		ifstream in(filePath);
		if (!in) {
			break;
		}

		string key;
		string value;
		while (in >> key >> value) {
			kvs[key] += stoull(value);
		}

		++i;
	}

	string buf;
	for (auto &it: kvs) {
		buf += it.first + ' ' + to_string(it.second) + '\n';
	}

	ofstream out(basedir + "mr-out", ios::out | ios::app);
	mtx.lock();
	out << buf;
	mtx.unlock();
	out.close();
}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	for (;;) {

		//
		// Lab2: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		mr_protocol::AskTaskResponse res;
		cl->call(mr_protocol::asktask, id, res);
		switch (res.tasktype) {
			case MAP:
				doMap(res.index, res.filename);
				doSubmit(MAP, res.index);
				break;

			case REDUCE:
				doReduce(res.index);
				doSubmit(REDUCE, res.index);
				break;

			default:
				sleep(1);
				break;
		}
	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

